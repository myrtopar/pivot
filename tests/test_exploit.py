import pytest
from autoexploit import Target

import pexpect

import logging
import os
import subprocess
import tempfile
import time

logging.basicConfig(
    filename="test.log",
    level=logging.DEBUG,
    format="%(asctime)s - %(levelname)s - %(message)s",
)


targets = {
    "iwconfig": Target(
        name="iwconfig",
        path="iwconfig",
        timeout=3,
        target_input="crash_inputs/iwconfig_input",
    )
}


ENTRYPOINT = "autoexploit"


@pytest.mark.parametrize("target_key", targets.keys())
def test_target(target_key: str):

    target = targets.get(target_key)
    assert target is not None, f"Target {target_key} not found in targets dictionary"
    logging.info(f"Testing target: {target.name}")
    invocation = [
        ENTRYPOINT, "-i", target.target_input, target.path, "@@"
    ]
    logging.info(f"Invocation: {' '.join(invocation)}")
    try:
        # launch with a temporary directory
        with tempfile.TemporaryDirectory() as temp_dir:
            logging.info(f"Using temporary directory: {temp_dir}")
            os.environ["TMPDIR"] = temp_dir
            child = pexpect.spawn(
                " ".join(invocation),
                encoding="utf-8",
            )
            logging.info(f"Spawned child process with PID: {child.pid}")
            # wait for "$" prompt to appear
            child.expect(r"\$", timeout=target.timeout)
            logging.info("Prompt detected, sending command to create output file")
            child.sendline(f"touch {temp_dir}/output")
            child.expect(r"\$", timeout=target.timeout)
            stdout, stderr = child.before, child.after
            logging.info(f"Child process output: {stdout}")
            logging.info(f"Child process error output: {stderr}")
            child.sendline("whoami")
            # wait for the command to finish
            child.expect(r"\$", timeout=target.timeout)
            stdout, stderr = child.before, child.after
            logging.info(f"Child process output: {stdout}")
            logging.info(f"Child process error output: {stderr}")
            logging.info("Command finished, checking for output file")
            # kill the child process
            child.terminate()
            child.wait()
            logging.info(f"Child process finished with PID: {child.pid}")
            logging.info(f"Child process exit status: {child.exitstatus}")
            assert os.path.exists(f"{temp_dir}/output")
            logging.info("Test passed: file created")
    except Exception as e:
        logging.error(f"Failed to start process: {e}")
        raise


def internal_test():

    # ra_offset = locate_ra(generate_testcase(), target_bin)
    # build_payload(ra_offset, target_bin)
    exploit_cmd = build_command(target)

    attach_strace()

    # performing brute force attack
    i = 0
    while True:
        # print(f"Attempt: {i}")
        i += 1

        if i >= 200:
            exploit_proc.close()
            os.remove("/app/trash")
            os.remove("/app/payload")
            os.remove("/app/strace.log")
            assert False

        exploit_proc = run_exploit(exploit_cmd)

        try:
            while True:

                if detect_execve():
                    assert True  # exploit succeeded, shell spawned but not interactively for testing purposes. Test passed
                    exploit_proc.close()
                    os.remove("/app/trash")
                    os.remove("/app/payload")
                    os.remove("/app/strace.log")
                    return

                output = exploit_proc.recv(
                    timeout=0.2
                )  # timeout -> give enough time for target bin to read the payload and for recv to consume the content of the pty output buffer: 0.1 was not enough apparently
                if output:
                    if detect_crash(exploit_proc.pid) or i == 1:
                        truncate_log()
                        break
                else:
                    break

        except EOFError:
            logging.warning("No output received, breaking out of loop.")

        exploit_proc.close()


def do_nottest_exploit2():

    # target_bins = ['vuln', 'iwconfig', 'ncompress']

    # for target in target_bins:
    #     test_target(target)

    vuln_cmd = [
        "python3",
        "src/autoexploit.py",
        "-i",
        "crash_inputs/vuln_input",
        "vuln",
    ]
    iwconfig_cmd = [
        "python3",
        "src/autoexploit.py",
        "-i",
        "crash_inputs/iwconfig_input",
        "iwconfig",
        "@@",
    ]
    ncompress_cmd = [
        "python3",
        "src/autoexploit.py",
        "-i",
        "crash_inputs/ncompress_input",
        "ncompress",
        "@@",
    ]

    test_target(vuln_cmd)
    test_target(iwconfig_cmd)
    test_target(ncompress_cmd)


def do_not_test_target(target_cmd):

    test_proc = subprocess.Popen(
        target_cmd, stdout=subprocess.PIPE, text=True, start_new_session=True
    )

    time.sleep(15)
    os.killpg(test_proc.pid, signal.SIGKILL)

    # os.remove("/app/trash")
    # os.remove("/app/payload")
    # os.remove("/app/strace.log")

    with open("app.log", "r") as applog:
        lines = applogging.readlines()
        for line in lines:
            if "Switching to interactive mode" in line:
                assert True
                break
        else:
            assert False
    os.remove("/app/app.log")
